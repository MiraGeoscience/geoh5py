// keep in mind: these same services will also be implement by Geoscience Analyst
// to operate on the current open workspace.
// The same geoh5io client can connect indifferently to a geoh5 server or to Geoscience Analyst.

// TODO: the server flag any modified entity so that it knows what needs to be to saved
// (thus, flag any new object as modified). Also update last modified date?

// TODO: define a scenario for a demo, so that implementation is prioritized accordingly

/**
 * The version of this API. This is different form the version of the geoh5 file format.
 *
 * Follows Semantic Versioning.
 */
const string API_VERSION = "0.1.0";

/**
 * A version string. Refers to `Semantic Versioning <https://semver.org/>` for a proper formatting
 * (major.minor.patch[-preReleaseID][+buildID]).
 */
VersionString {
    1: string string
}

/**
 * A version represented as floating point number (major.minor),
 * as in the geoh5 format version.
 */
VersionNumber {
    1: double number;
}

/**
 * A UUID. Can be null.
 */
struct Uuid {
   1: optional string id;  // 'optional' allows for null Uuid.
}

/**
 * UTC date and time, represented by text according to the ISO 8601 specifications,
 * taking the form YYYY-MM-DDTHH:mm:ss[Z|[+|-]HH:mm].
 */
struct DateTime {
    1: optional string string; // optional allows for null DateTime
}

/**
 * Exception thrown upon a read/write error on file.
 */
exception FileIOException {
    1: what string;
}

/**
 * Exception thrown upon a parse error on file.
 */
exception FileFormatException {
    1: what string;
}

/**
 * Exception thrown when a given Uuid is invalid or refers to an unexpected entity type.
 */
exception InvalidUid {
    1: what string;
}

/**
 * Exception thrown when a given Entity reference (usually through a Uuid)
 * is not pointing to an Entity of the expected type.
 */
exception BadEntityType {
    1: what string;
}

/**
 * Exception thrown when trying to rename an entity with an unauthorized name.
 */
exception BadEntityName {
    1: what string;
}

/**
 * Exception thrown when failing to apply an operation that modifies an Object.
 */
exception InvalidObjectOperation {
    1: what string;
}

/**
 * Exception thrown when failing to apply an operation that modifies Data.
 */
exception InvalidDataOperation {
    1: what string;
}

/**
 * Exception thrown when failing to apply an operation that modifies Group.
 */
exception InvalidGroupOperation {
    1: what string;
}

/**
 * Describes an workspace.
 */
Workspace {
    1: file_path string; // empty if this workspace has not been saved yet.
    2: VersionNumber version;
    3: DistanceUnit distance_unit;
    4: DateTime date_created;
    5: DateTime date_modified;
}

/**
 * Defines operation on the current open workspace.
 *
 * The workspace may be created from scratch, or loaded from a geoh5 file.
 */
service WorkspaceService {
    /**
     * Returns the API version of the server,
     * which may differ from the one of the client (see API_VERSION).
     */
    VersionString get_api_version();

    /**
     * Creates a new empty Workspace and saves at the given file location on server.
     *
     * In case of success, the new workspace becomes current.
     * Closes the current workspace beforehand.
     */
    Workspace create_geoh5(1: required string file_path) throws (1:FileIOException io_ex);

    /**
     * Opens the geoh5 file as read-only at the given path location on server,
     * and loads its content as the current Workspace.
     *
     * Closes the current workspace beforehand.
     */
    Workspace open_geoh5(1: required string file_path)
        throws (1:FileIOException io_ex, 2: FileFormatException fmt_ex);

    /**
     * Saves the current workspace at the given file location on server.
     *
     * In case of success, the current workspace now refers to this new file location.
     * Closes the previously opened workspace file, if any.
     *
     * If file_path is the same the current workspace file, and overwrite_file is true,
     * then the original file is updated.
     */
    Workspace save(1: required string file_path, 2: optional bool overwrite_file = false)
        throws (1:FileIOException io_ex);

    /**
     * Saves the current workspace at the given file location on server.
     *
     * The current open workspace does not change and still refers to the initially
     * opened geoh5 file, if any.
     *
     * Even it overwrite_file is true, it will refuse to overwrite the file of the
     * current open workspace.
     */
    Workspace save_copy(1: required string file_path, 2: optional bool overwrite_file = false)
        throws (1:FileIOException io_ex);

    /**
     * Saves the given list of Objects/Groups as a new geoh5 file at the given file location on server.
     *
     * The current open workspace does not change and still refers to the initially
     * opened geoh5 file, if any.
     *
     * Even it overwrite_file is true, it will refuse to overwrite the file of the
     * current open workspace.
     */
    Workspace export_objects(
        1: required list<Uuid> objects_or_groups, 2: required string file_path,
        3: optional bool overwrite_file = false
    ) throws (1:FileIOException io_ex, 2:InvalidUid uuid_ex, 3:BadEntityType bad_type_ex);

    /**
     * Closes the current workspace and the associated geoh5 file if any.
     */
    void close();

    /**
     * Gets list of contributors for the current open geoh5 workspace.
     *
     * Note: the contributor list of a workspace is update with current
     * user every time the workspace is saved
     */
    list<string> get_contributors();
}

/**
 * Base structure that holds attributes common to Object, Data and Group entities.
 */
struct Entity {
   1: required Uuid uid;
   2: required Uuid type;
   3: required string name;
   4: optional bool visible = false;
   5: optional bool allow_delete = true;
   6: optional bool allow_rename = true;
   7: optional bool is_public = true;
}

/**
 * Defines operations common to all Entity types (Objects, Groups, Data).
 */
service EntityService {
    /**
     * Sets/unsets the public flag on each Entity of the given list.
     */
    void set_public(1: required list<Uuid> entities , 2: required bool public)
        throws (1:InvalidUid uuid_ex);

    /**
     * Sets/unsets the visible flag on each Entity of the given list.
     */
    void set_visible(1: required list<Uuid> entities, 2: required bool visible)
        throws (1:InvalidUid uuid_ex);

    /**
     * Sets/unsets the delete permission on each Entity of the given list.
     */
    void set_allow_delete(1: required list<Uuid> entities, 2: required bool allow)
        throws (1:InvalidUid uuid_ex);

    /**
     * Sets/unsets the rename permission on each Entity of the given list.
     */
    void set_allow_rename(1: required list<Uuid> entities, 2: required bool allow);
        throws (1:InvalidUid uuid_ex);

    /**
     * Renames the given Entity.
     */
    void rename(1: required Uuid entities, 2: required string new_name)
        throws (1:InvalidUid uuid_ex, 2:BadEntityName name_ex);
}

/**
 * Contains the base Entity attributes and more attributes specific to Object.
 */
struct Object {
   1: required Entity base_;
   2: optional bool allow_move = true;
   // geoh5 also has: list<Uuid> clipping_uids; -- Do not expose in the API, until it allows for manipulation of clipping planes
}

/**
 * Query parameters to look for Objects.
 */
struct ObjectQuery {
   1: optional string name;
   1: optional Uuid type;
   3: optional Uuid in_group;
   4: optional recursive = false;
}

/**
 * Describes the known type of Objects.
 *
 * Use ObjectService to obtain a ObjectClass value from an Object type Uuid.
 */
enum ObjectClass {
   UNKNOWN = 0
   POINTS,
   CURVE,
   SURFACE,
   GRID2D,
   DRILLHOLE,
   BLOCKMODEL,
   OCTREE,
   GEOIMAGE,
   LABEL,
}

struct Coord3D {
    1: required double x = 0.;
    2: required double y = 0.;
    3: required double z = 0.;
}

struct GeometryTransformation {
   1: Coord3D translation;
   2: double rotation_deg;
}

/**
 * Defines operations on Objects.
 */
service ObjectService extends EntityService {
    /**
     * Returns the Uuid for the Object type that corresponds to the given ObjectClass.
     *
     * Returns an empty Uuid for ObjectClass.UNKNOWN.
     */
    Uuid get_type(1: required ObjectClass object_class);

    /**
     * Returns the ObjectClass for the given Object type.
     *
     * May return ObjectClass.UNKNOWN if the given type does not correspond to any known type.
     */
    ObjectClass get_class(1: required Uuid type)
        throws (1:InvalidUid uuid_ex);

    list<Object> get_all();
    list<Object> find(1: required ObjectQuery query)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    /**
     * Sets/unsets the move permission on each Object of the given list.
     */
    void set_allow_move(1: required list<Uuid> objects, 2: required bool allow);
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    /**
     * Moves each Object of the given list under the destination group.
     */
    void move_to_group(1: required list<Uuid> objects, 2: required Uuid destination_group)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex, 3:InvalidObjectOperation op_ex);

    Object get(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Points narrowPoints(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Curve narrowCurve(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Surface narrowSurface(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Grid2D narrowGrid2D(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Drillhole narrowDrillhole(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    BlockModel narrowBlockModel(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Octree narrowOctree(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    GeoImage narrowGeoImage(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    Label narrowLabel(1: required Uuid uid)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    // Below, methods for creating new Objects.
    // When creating object, group is optional. The object gets created under the root container
    // if group is not specified.

    Object createAnyObject(
        1: required Uuid type, 2: required string name,
        3: optional Uuid parent_group, 4: dict<string, string> attributes
     ) throws (1:BadEntityName name_ex, 2:InvalidUid uuid_ex, 3:BadEntityType bad_type_ex);

    // TODO: for each object type, have a specific set of parameters
    // Points objectService.createPoints(1: required string name, 2: optional Uuid parent_group, /*specific parameters... */) throws (1:BadEntityName name_ex, 2:InvalidUid uuid_ex, 3:BadEntityType bad_type_ex);
    // Curve objectService.createCurve(1: required string name, 2: optional Uuid parent_group, /*specific parameters... */) throws (1:BadEntityName name_ex, 2:InvalidUid uuid_ex, 3:BadEntityType bad_type_ex);
    // ...

    void transform(1: required list<Uuid> objects, 2: required GeometryTransformation transformation)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex, 3:InvalidObjectOperation op_ex);
}

// TODO if specific operations per class, other than create: introduce CurveService, SurfaceService, ...

/**
 * Describes how the Data is tied to its parent Entity: vertex, face, cell, or the object/group itself.
 */
enum DataAssociation {
   UNKOWN = 0,
   OBJECT,
   CELL,
   FACE,
   VERTEX,
}

enum PrimitiveDataType {
    INTEGER,
    FLOAT,
    REFERENCED,
    TEXT,
    FILENAME,
    DATETIME,
    BLOB
}

/**
 * Contains the base Entity attributes and more attributes specific to Data.
 */
Data {
   1: required Entity base_;
   2: required association DataAssociation
}

DataType {
   // TODO: ... see UML ...
   PrimitiveDataType primitiveType
   units: DataUnit
}

DataSlab {
   1: required start i64 = 0;
   // TODO...
}

union DataValues { // TODO
    // only one of them is set
    list<int>, // warning: no unsigned int in thrift
    list<float>,
    list<string>,
    // TODO: blob
}

/**
 * Query parameters to look for Data.
 */
struct DataQuery {
   1: optional string name;
   2: optional Uuid object_or_group; // Data can be attached to an Object or a Group
   3: optional PrimitiveType primitive_type;
   4: optional DataAssociation association;
}

service DataService extends EntityService { // TODO: cleanup
    getAll() => Data[]
    getAllOfType(dataType_uuid) => Data[]
    find(DataQuery) => Data[]
    get(uuid) => Data
    getValues(uuid) => DataValues
    create(objectUuid, association, dataTypeID, ...) => Data

    // alternatively
    // getIntegerValues(uuid) => int[]
    // getFloatValues(uuid) => float[]
    // getReferenceValues(uuid) => uint[]
    // getTextValues(uuid) => string[]
    // getFileNameValues(uuid) => string[]
    // getDateTimeValues(uuid) => string[]
    // getBlobValues(uuid) => ???

    getAllTypes(primitiveType) => DataType[] // primitiveType optional
    get(uuid) => DataType
    getValues(uuid) => DataType // the offset of the starting element of the specified
    create(...) => DataType
}

// TODO: how are managed data groups? Should a group be part of DataQuery

/**
 * Contains the base Entity attributes and more attributes specific to Group.
 */
struct Group {
   1: required Entity base_;
   2: optional bool allowMove = true;
   // geoh5 also has: list<Uuid> clipping_uids; -- Do not expose in the API, until it allows for manipulation of clipping planes
}

struct GroupQuery {
   1: optional string name;
   2: optional Uuid type;
   3: optional Uuid in_group;
   4: optional recursive = false;
}

/**
 * Describes the known type of Groups.
 *
 * Use GroupService to obtain a GroupClass value from an Group type Uuid.
 */
enum GroupClass {
   UNKNOWN = 0
   CONTAINER,
   DRILLHOLE,
   // TODO: more undocumented groups
}

service GroupService extends EntityService { // TODO: cleanup
    /** Returns the root container of the current open Workspace. */
    Group get_root();

    /**
     * Returns the Uuid for the Group type that corresponds to the given GroupClass.
     *
     * Returns an empty Uuid for GroupClass.UNKNOWN.
     */
    Uuid get_type(1: required GroupClass group_class);

    /**
     * Returns the GroupClass for the given Group type.
     *
     * May return GroupClass.UNKNOWN if the given type does not correspond to any known type.
     */
    GroupClass get_class(1: required Uuid type)
        throws (1:InvalidUid uuid_ex);

    list<Group> get_all();
    list<Group> find(1: required ObjectQuery query)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    /**
     * Sets/unsets the move permission on each Group of the given list.
     */
    void set_allow_move(1: required list<Uuid> groups, 2: required bool allow);
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);

    /**
     * Moves each Group of the given list under the given destination group.
     */
    void move_to_group(1: required list<Uuid> groups, 2: required Uuid destination_group)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex, 3:InvalidGroupOperation op_ex);

    // type defaults to Uuid for GroupClass.CONTAINER if not specified
    Group create(1: optional Uuid type, TODO...)
        throws (1:InvalidUid uuid_ex, 2:BadEntityType bad_type_ex);


    // TODO? allow creation of new GroupTypes?
}

// TODO: read/write and assign clipping planes?
// TODO: manage viewports, and visibility per viewport
// TODO: read/write Entity MetaData


